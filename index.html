<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Efecto de Escritura de Código</title>
    
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>

    <style>
        body {
            background: #111;
            position: relative;
            height: 100%;
            margin: 0; 
            padding: 20px;
        }

        html {
            height: 100%;
        }

        .text span {
            min-width: 5px;
            display: inline-block;
            font-family: 'Source Sans Pro', sans-serif;
            font-size: 0.85em;
            letter-spacing: 1.5px;
            color: #ED1B34;
        }
        
        .text {
            overflow: hidden;
            height: auto;
            white-space: pre-wrap; 
        }

        .text .line {
            display: block; 
            margin: 0;
            padding: 0;
        }
    </style>
</head>
<body>

    <p class="text" data-text="struct group_info init_groups = { .usage = ATOMIC_INIT(2) };\n\nstruct group_info *groups_alloc(int gidsetsize){\n    struct group_info *group_info;\n    int nblocks;\n    int i;\n\n    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK;\n    /* Make sure we always allocate at least one indirect block pointer */\n    nblocks = nblocks ? : 1;\n    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER);\n    if (!group_info)\n        return NULL;\n\n    group_info->ngroups = gidsetsize;\n    group_info->nblocks = nblocks;\n    atomic_set(&group_info->usage, 1);\n\n    if (gidsetsize <= NGROUPS_SMALL)\n        group_info->blocks[0] = group_info->small_block;\n    else {\n        for (i = 0; i < nblocks; i++) {\n            gid_t *b;\n            b = (void *)__get_free_page(GFP_USER);\n            if (!b)\n                goto out_undo_partial_alloc;\n            group_info->blocks[i] = b;\n        }\n    }\n    return group_info;\n\nout_undo_partial_alloc:\n\n    while (--i >= 0) {\n\n        free_page((unsigned long)group_info->blocks[i]);\n\n    }\n\n    kfree(group_info);\n\n    return NULL;\n\n}\n\nEXPORT_SYMBOL(groups_alloc);\n\nvoid groups_free(struct group_info *group_info)\n\n{\n\n    if (group_info->blocks[0] != group_info->small_block) {\n\n        int i;\n\n        for (i = 0; i < group_info->nblocks; i++) {\n            free_page((unsigned long)group_info->blocks[i]);\n        }\n    }\n    kfree(group_info);\n}\n\n// FIN DEL CÓDIGO"></p>

    <script>
    $(document).ready(function() {
        var printText = $('.text').data('text');
        
        var contentArray = printText.split('\n');

        $('.text').empty();

        var totalDelay = 0;
        var lineDelay = 50;
        var charDelay = 10; 

        $.each(contentArray, function(lineIndex, lineContent) {
            var $newLineContainer = $('<span class="line" id="line-' + lineIndex + '"></span>');
            $('.text').append($newLineContainer);
            
            var currentLineStartDelay = totalDelay;

            setTimeout(function () {
                var characters = lineContent.split('');

                $.each(characters, function(charIndex, character){
                    setTimeout(function () {
                        $newLineContainer.append("<span>" + character + "</span>");
                        $('body, html').scrollTop($(document).height());
                    }, charIndex * charDelay);
                });
            }, currentLineStartDelay);
            
            totalDelay += (lineContent.length * charDelay) + lineDelay;
        });
    });
    </script>

</body>
</html>
